<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>9-2절 오버라이드</title>
    <script>
      class LifeCycle {
        call() {
          this.a();
          this.b();
          this.c();
        }

        a() {
          console.log("a() 메소드를 호출합니다.");
        }
        b() {
          console.log("b() 메소드를 호출합니다.");
        }
        c() {
          console.log("c() 메소드를 호출합니다.");
        }
      }

      new LifeCycle().call();

      console.log("============ child =============");

      class Child extends LifeCycle {
        // 부모 클래스에 있던 메소드를 상속받은 자식 클래스에서 다시 만들어 덮어씌우는 것을 '오버라이드한다'고 표현한다.
        a() {
          console.log("자식의 a() 메소드입니다.");
        }

        // 부모 클래스에 있는 메소드 내용도 함께 사용하고 싶을 경우 super 키워드를 사용한다. 9-2-1의 super()와 헷갈리는데 super 키워드가 2가지 사용법을 가지고 있어서 그렇다. https://ko.javascript.info/class-inheritance 해당 문서 참고하기!
        b() {
          super.b(); // 부모의 메소드를 실행하는 코드
          console.log("자식의 b() 메소드입니다.");
        }
      }

      new Child().call();

      console.log("============ Example =============");

      class Pet {
        constructor(name, age) {
          this.name = name;
          this.age = age;
        }

        // 클래스를 생성할 때 자바스크립트의 최상위 클래스인 Object를 자동으로 상속 -> toString() 메소드를 상속받은 상태에서 오버라이드
        toString() {
          return `이름: ${this.name}\n나이: ${this.age}살`;
        }
      }

      const pet = new Pet("구름", 6);
      // alert() 함수는 매개변수로 받은 자료를 문자열로 바꾼 뒤 출력하기 때문에 오버라이드한 toString() 메소드가 실행된다.
      alert(pet);
      console.log(pet);
      // 문자열과 다른 자료형을 결합할 때도 내부적으로 다른 자료형을 문자열로 변환한 뒤 결합시키기 때문에 오버라이드한 toString() 메소드가 실행된다.
      console.log(pet + "");
    </script>
  </head>
  <body></body>
</html>
