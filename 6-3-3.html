<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>6-3절 전개 연산자를 활용한 깊은 복사</title>
    <script>
      console.log("============== 배열 ==============");
      // 배열과 객체는 할당할 때 '얕은 복사(참조 복사)'가 이루어진다. '얕은 복사'란 복사하는 행위가 단순하게 다른 이름을 붙이는 형태로 동작하는 복사를 의미한다.
      const 물건_200301 = ["우유", "식빵"];
      const 물건_200302 = 물건_200301;
      물건_200302.push("고구마");
      물건_200302.push("토마토");

      console.log("01 : ", 물건_200301);
      console.log("02 : ", 물건_200302);
      // 같은 값이 나옴

      // 두 배열이 완전히 독립적으로 작동하려면 '깊은 복사'를 해야한다. (클론clone을 만드는 것이라고 표현) 깊은 복사는 전개 연산자를 사용한다 (5-1절 참고)
      const 물건_200303 = ["우유", "식빵"];
      const 물건_200304 = [...물건_200303];
      물건_200304.push("고구마");
      물건_200304.push("토마토");

      console.log("03 : ", 물건_200303);
      console.log("04 : ", 물건_200304);

      // 자료를 추가하는 건 다음처럼 간단하게 작성할 수 있다
      const 물건_200305 = ["우유", "식빵"];
      const 물건_200306 = ["고구마", ...물건_200305, "토마토"];
      // 해당 위치에 복사되어 전개되는 것이므로 원하는 위치에 놓아서 요소들의 순서를 바꿀 수 있다

      console.log("05 : ", 물건_200305);
      console.log("06 : ", 물건_200306);

      // 배열을 여러 번 전개할 수도 있다
      const a = ["우유", "식빵"];
      const b = ["고구마", "토마토"];
      const c = [...a, ...b];
      const d = [...b, ...a];

      console.log("c : ", c);
      console.log("d : ", d);

      console.log("============== 객체 ==============");
      // 객체도 배열과 마찬가지
      const 구름1 = {
        이름: "구름",
        나이: 6,
        종족: "강아지",
      };

      const 별1 = 구름1;
      별1.이름 = "별";
      별1.나이 = 1;

      console.log("구름1 : ", JSON.stringify(구름1));
      console.log("별1 : ", JSON.stringify(별1));
      // 얕은 복사가 되어 두 객체가 동일해진다

      const 구름2 = {
        이름: "구름",
        나이: 6,
        종족: "강아지",
      };

      const 별2 = { ...구름2 };
      별2.이름 = "별";
      별2.나이 = 1;

      console.log("구름2 : ", JSON.stringify(구름2));
      console.log("별2 : ", JSON.stringify(별2));

      // 자료 추가
      const 별3 = {
        ...구름2,
        이름: "별", // 기존의 속성 덮어쓰기
        나이: 1, // 기존의 속성 덮어쓰기
        예방접종: true,
      };
      // 굳이 덮어쓰지 않은 '종족' 속성도 복사되어 별3에 들어가있다
      console.log("별3 : ", JSON.stringify(별3));

      // !!전개 순서가 매우 중요!! 별3은 구름2를 먼저 전개했으므로 이후 작성한 '이름'과 '나이' 속성이 구름2 객체 안에 있는 이름, 나이 속성을 덮어쓰게 된다. 만약 구름2를 뒤에서 전개할 경우 아래와 같이 된다.
      const 별4 = {
        이름: "별",
        나이: 1,
        예방접종: true,
        ...구름2,
      };
      console.log("별4 : ", JSON.stringify(별4));
      // 별4는 이름과 나이 속성이 구름2의 값으로 덮어씌워졌으며, 속성의 순서도 별3과 다르다. 별3은 '구름-별3에서 추가한 속성' 순서이므로 '이름-나이-종족-예방접종' 순서로 객체가 형성되지만, 별4는 '별4로 추가한 속성-구름2' 순서이므로 '이름-나이-예방접종-종족' 순으로 객체가 형성되어있다.

      // 별3 혹은 아래 코드와 같이 앞에서 전개하는 방식이 최신 자바스크립트에서 객체 속성에 기본값(기본 속성)을 부여하는 첫 번째 방법. 별4처럼 뒤에서 전개하면 앞에 입력한 값을 복사한 값이 덮어쓰게 되어 기본값의 의미가 없어진다.
      const test1 = function (object) {
        // 6-3-2에서 사용한 다중 할당과 깊은 복사를 동시에 사용하고 있는 코드. 일일이 object.속성을 쓰지 않고 일괄적으로 객체의 속성을 모두 추출하고 있으며, 동시에 status 속성에 기본값을 주고 있다.
        const { name, age, color, status } = { status: "이상없음", ...object };
        return `${name} : ${age} : ${color} : ${status}`;
      };

      console.log(
        test1({
          name: "구름",
          age: 7,
          color: "갈색",
        })
      );

      // 최신 자바스크립트로 기본 속성을 지정하는 두 번째 방법은 함수를 아예 재정의하는 것. (5-1-4 기본 매개변수 참고) 이 방식이 가장 현대적인 코드. test1과 달리 object라는 변수가 아예 사라졌으므로 객체 내부의 속성을 바로 return문에 꽂아넣고 있다.
      const test2 = function ({ name, age, color, status = "이상 없음" }) {
        return `${name} : ${age} : ${color} : ${status}`;
      };

      console.log(
        test2({
          name: "구름",
          age: 7,
          color: "갈색",
        })
      );
    </script>
  </head>
  <body></body>
</html>
